# AutoSend Webhooks - Verify Webhook Requests

Learn how to verify that webhook requests are genuinely from AutoSend using HMAC signature verification.

---

## Why Verify Webhooks?

**Security is critical.** Anyone can send a POST request to your webhook endpoint. Without verification, malicious actors could:

- Send fake events to corrupt your data
- Trigger unwanted actions in your application
- Cause your system to process fraudulent information
- Launch denial-of-service attacks

**Always verify webhook signatures** to ensure requests are genuinely from AutoSend.

---

## How AutoSend Signs Webhooks

Every webhook request from AutoSend includes an `X-Webhook-Signature` header containing an HMAC-SHA256 signature.

### Signature Generation

AutoSend generates the signature using this process:

1. **Take the raw request body** as a string (the JSON payload)
2. **Compute HMAC-SHA256** using your webhook secret as the key
3. **Convert to hexadecimal** format
4. **Add as header**: `X-Webhook-Signature: <signature>`

```javascript
// Pseudocode for how AutoSend generates signatures
const signature = crypto
  .createHmac("sha256", webhookSecret)
  .update(JSON.stringify(requestBody))
  .digest("hex");
```

---

## Webhook Request Headers

Every webhook request includes these headers:

| Header                  | Description                               | Example                 |
| ----------------------- | ----------------------------------------- | ----------------------- |
| `X-Webhook-Signature`   | HMAC-SHA256 signature of the request body | `a1b2c3d4e5f6...`       |
| `X-Webhook-Event`       | The event type                            | `email.opened`          |
| `X-Webhook-Delivery-Id` | Unique delivery identifier                | `delivery-123...`       |
| `X-Webhook-Timestamp`   | Unix timestamp when webhook was sent      | `1699790400`            |
| `Content-Type`          | Always `application/json`                 | `application/json`      |
| `User-Agent`            | AutoSend user agent                       | `AutoSend-Webhooks/1.0` |

---

## Verifying Signatures

### Verification Steps

1. **Extract the signature** from the `X-Webhook-Signature` header
2. **Get the raw request body** as a string (before parsing)
3. **Compute the expected signature** using your webhook secret
4. **Compare signatures** using a constant-time comparison function

### Node.js Implementation

```javascript
const express = require("express");
const crypto = require("crypto");

const app = express();

// Important: Store raw body for signature verification
app.use(
  express.json({
    verify: (req, res, buf) => {
      req.rawBody = buf.toString("utf8");
    },
  })
);

function verifyWebhookSignature(req, webhookSecret) {
  const receivedSignature = req.headers["x-webhook-signature"];

  if (!receivedSignature) {
    return false;
  }

  // Compute expected signature using raw body
  const expectedSignature = crypto
    .createHmac("sha256", webhookSecret)
    .update(req.rawBody)
    .digest("hex");

  // Use constant-time comparison to prevent timing attacks
  return crypto.timingSafeEqual(
    Buffer.from(receivedSignature),
    Buffer.from(expectedSignature)
  );
}

app.post("/webhooks/autosend", (req, res) => {
  const webhookSecret = process.env.WEBHOOK_SECRET;

  // Verify signature
  if (!verifyWebhookSignature(req, webhookSecret)) {
    console.error("Invalid webhook signature");
    return res.status(401).json({ error: "Invalid signature" });
  }

  // Process webhook
  const { event, data } = req.body;
  console.log(`Verified webhook: ${event}`);

  res.status(200).json({ received: true });
});
```

### Python (Flask) Implementation

```python
from flask import Flask, request, jsonify
import hmac
import hashlib
import os

app = Flask(__name__)
WEBHOOK_SECRET = os.getenv('WEBHOOK_SECRET')

def verify_webhook_signature(payload, signature, secret):
    """Verify webhook signature using HMAC-SHA256"""
    if not signature:
        return False

    # Compute expected signature
    expected = hmac.new(
        secret.encode('utf-8'),
        payload.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()

    # Constant-time comparison
    return hmac.compare_digest(expected, signature)

@app.route('/webhooks/autosend', methods=['POST'])
def webhook():
    # Get signature from header
    signature = request.headers.get('X-Webhook-Signature')

    # Get raw payload
    payload = request.get_data(as_text=True)

    # Verify signature
    if not verify_webhook_signature(payload, signature, WEBHOOK_SECRET):
        return jsonify({'error': 'Invalid signature'}), 401

    # Parse and process webhook
    data = request.json
    event = data.get('event')
    print(f'Verified webhook: {event}')

    return jsonify({'received': True}), 200

if __name__ == '__main__':
    app.run(port=3000)
```

### PHP Implementation

```php
<?php
function verifyWebhookSignature($payload, $receivedSignature, $secret) {
    if (empty($receivedSignature)) {
        return false;
    }

    // Compute expected signature
    $expectedSignature = hash_hmac('sha256', $payload, $secret);

    // Constant-time comparison
    return hash_equals($expectedSignature, $receivedSignature);
}

// Get raw POST body
$payload = file_get_contents('php://input');

// Get signature from header
$signature = $_SERVER['HTTP_X_WEBHOOK_SIGNATURE'] ?? '';

// Get secret from environment
$webhookSecret = getenv('WEBHOOK_SECRET');

// Verify signature
if (!verifyWebhookSignature($payload, $signature, $webhookSecret)) {
    http_response_code(401);
    echo json_encode(['error' => 'Invalid signature']);
    exit;
}

// Parse and process webhook
$data = json_decode($payload, true);
$event = $data['event'];

error_log("Verified webhook: $event");

http_response_code(200);
echo json_encode(['received' => true]);
?>
```

### Ruby (Sinatra) Implementation

```ruby
require 'sinatra'
require 'json'
require 'openssl'

WEBHOOK_SECRET = ENV['WEBHOOK_SECRET']

def verify_webhook_signature(payload, signature, secret)
  return false if signature.nil? || signature.empty?

  # Compute expected signature
  expected = OpenSSL::HMAC.hexdigest('sha256', secret, payload)

  # Constant-time comparison
  Rack::Utils.secure_compare(expected, signature)
end

post '/webhooks/autosend' do
  # Get raw body and signature
  payload = request.body.read
  signature = request.env['HTTP_X_WEBHOOK_SIGNATURE']

  # Verify signature
  unless verify_webhook_signature(payload, signature, WEBHOOK_SECRET)
    status 401
    return { error: 'Invalid signature' }.to_json
  end

  # Parse and process webhook
  data = JSON.parse(payload)
  event = data['event']

  puts "Verified webhook: #{event}"

  status 200
  { received: true }.to_json
end
```

### Go Implementation

```go
package main

import (
    "crypto/hmac"
    "crypto/sha256"
    "encoding/hex"
    "encoding/json"
    "io/ioutil"
    "net/http"
    "os"
)

func verifyWebhookSignature(payload []byte, signature string, secret string) bool {
    if signature == "" {
        return false
    }

    // Compute expected signature
    mac := hmac.New(sha256.New, []byte(secret))
    mac.Write(payload)
    expected := hex.EncodeToString(mac.Sum(nil))

    // Constant-time comparison
    return hmac.Equal([]byte(expected), []byte(signature))
}

func webhookHandler(w http.ResponseWriter, r *http.Request) {
    // Read raw body
    payload, err := ioutil.ReadAll(r.Body)
    if err != nil {
        http.Error(w, "Error reading body", http.StatusBadRequest)
        return
    }

    // Get signature from header
    signature := r.Header.Get("X-Webhook-Signature")

    // Get secret from environment
    webhookSecret := os.Getenv("WEBHOOK_SECRET")

    // Verify signature
    if !verifyWebhookSignature(payload, signature, webhookSecret) {
        http.Error(w, "Invalid signature", http.StatusUnauthorized)
        return
    }

    // Parse webhook
    var data map[string]interface{}
    json.Unmarshal(payload, &data)

    // Process webhook
    event := data["event"].(string)
    println("Verified webhook:", event)

    w.WriteHeader(http.StatusOK)
    json.NewEncoder(w).Encode(map[string]bool{"received": true})
}

func main() {
    http.HandleFunc("/webhooks/autosend", webhookHandler)
    http.ListenAndServe(":3000", nil)
}
```

---

## Security Best Practices

### 1. Always Use Constant-Time Comparison

**Never use `===` or `==` to compare signatures.** Use constant-time comparison functions to prevent timing attacks:

```javascript
// ❌ Bad - Vulnerable to timing attacks
if (receivedSignature === expectedSignature) {
  // Process webhook
}

// ✅ Good - Constant-time comparison
if (
  crypto.timingSafeEqual(
    Buffer.from(receivedSignature),
    Buffer.from(expectedSignature)
  )
) {
  // Process webhook
}
```

### 2. Store Secrets Securely

Never hardcode webhook secrets in your code:

```javascript
// ❌ Bad
const WEBHOOK_SECRET = "a1b2c3d4e5f6g7h8...";

// ✅ Good
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;

if (!WEBHOOK_SECRET) {
  throw new Error("WEBHOOK_SECRET environment variable is required");
}
```

**Store secrets in:**

- Environment variables
- Secure secret management services (AWS Secrets Manager, HashiCorp Vault, etc.)
- Encrypted configuration files

**Never:**

- Commit secrets to version control
- Include secrets in client-side code
- Share secrets in logs or error messages

### 3. Use the Raw Request Body

Compute signatures using the **raw, unparsed request body**:

```javascript
// ✅ Good - Use raw body
app.use(
  express.json({
    verify: (req, res, buf) => {
      req.rawBody = buf.toString("utf8");
    },
  })
);

const signature = crypto
  .createHmac("sha256", secret)
  .update(req.rawBody) // Use raw body
  .digest("hex");

// ❌ Bad - Don't re-stringify parsed body
const signature = crypto
  .createHmac("sha256", secret)
  .update(JSON.stringify(req.body)) // May not match original
  .digest("hex");
```

### 4. Validate the Timestamp

Optionally, validate the `X-Webhook-Timestamp` header to reject old requests:

```javascript
function isWebhookTimestampValid(timestamp, maxAgeSeconds = 300) {
  const now = Math.floor(Date.now() / 1000);
  const age = now - parseInt(timestamp);

  // Reject if older than 5 minutes
  return age < maxAgeSeconds && age > -60; // Allow 1 minute clock skew
}

app.post("/webhooks/autosend", (req, res) => {
  const timestamp = req.headers["x-webhook-timestamp"];

  if (!isWebhookTimestampValid(timestamp)) {
    return res.status(401).json({ error: "Timestamp too old" });
  }

  if (!verifyWebhookSignature(req, webhookSecret)) {
    return res.status(401).json({ error: "Invalid signature" });
  }

  // Process webhook
});
```

### 5. Use HTTPS

**Always use HTTPS** for your webhook endpoints in production:

```javascript
// ❌ Bad - HTTP in production
const webhookUrl = "http://api.example.com/webhooks/autosend";

// ✅ Good - HTTPS
const webhookUrl = "https://api.example.com/webhooks/autosend";
```

HTTPS ensures:

- Requests are encrypted in transit
- Man-in-the-middle attacks are prevented
- Webhook data remains confidential

### 6. Rotate Secrets Periodically

Regularly rotate your webhook secrets:

1. Create a new webhook with a new secret
2. Update your application to accept both old and new secrets temporarily
3. Switch traffic to the new webhook
4. Remove the old webhook

```javascript
// Support multiple secrets during rotation
const WEBHOOK_SECRETS = [
  process.env.WEBHOOK_SECRET,
  process.env.WEBHOOK_SECRET_OLD, // Remove after rotation complete
].filter(Boolean);

function verifyWithMultipleSecrets(req) {
  return WEBHOOK_SECRETS.some((secret) => verifyWebhookSignature(req, secret));
}
```

---

## Troubleshooting

### Signature Verification Failing

**Symptoms**: All webhook requests return 401 Unauthorized

**Common Causes:**

1. **Using wrong secret**

   ```javascript
   // Check which secret you're using
   console.log("Using secret starting with:", webhookSecret.substring(0, 10));
   ```

2. **Body parsing issues**

   ```javascript
   // Ensure you're using raw body
   console.log("Raw body:", req.rawBody);
   console.log("Parsed body:", JSON.stringify(req.body));
   ```

3. **String encoding issues**

   ```javascript
   // Ensure consistent encoding
   const expectedSignature = crypto
     .createHmac("sha256", webhookSecret)
     .update(req.rawBody, "utf8") // Explicit encoding
     .digest("hex");
   ```

4. **Comparing wrong values**
   ```javascript
   // Debug signature comparison
   console.log("Received signature:", receivedSignature);
   console.log("Expected signature:", expectedSignature);
   console.log("Match:", receivedSignature === expectedSignature);
   ```

### Testing Signature Verification

Test your signature verification locally:

```javascript
const crypto = require("crypto");

function testSignatureVerification() {
  const webhookSecret = "test-secret-12345";
  const payload = JSON.stringify({
    event: "email.opened",
    timestamp: "2025-11-12T10:30:00.000Z",
    data: { emailId: "test-123" },
  });

  // Generate signature
  const signature = crypto
    .createHmac("sha256", webhookSecret)
    .update(payload)
    .digest("hex");

  console.log("Test payload:", payload);
  console.log("Test signature:", signature);

  // Verify it works
  const expectedSignature = crypto
    .createHmac("sha256", webhookSecret)
    .update(payload)
    .digest("hex");

  console.log("Verification:", signature === expectedSignature);
}

testSignatureVerification();
```

---

## Retrieving Your Webhook Secret

If you've lost your webhook secret, you can retrieve it:

### Via Dashboard

1. Navigate to **Webhooks** in your AutoSend dashboard
2. Click on the webhook
3. Click **"Reveal Secret"**
4. Copy the secret and store it securely

### Via API

```bash
curl -X GET https://api.autosend.io/api/v1/webhooks/YOUR_WEBHOOK_ID/reveal \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "x-project-id: YOUR_PROJECT_ID"
```

**Response:**

```json
{
  "success": true,
  "data": {
    "secret": "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6..."
  }
}
```

---

## Complete Example

Here's a complete, production-ready webhook endpoint with signature verification:

```javascript
const express = require("express");
const crypto = require("crypto");
const app = express();

// Store raw body for signature verification
app.use(
  express.json({
    verify: (req, res, buf) => {
      req.rawBody = buf.toString("utf8");
    },
  })
);

// Webhook secret from environment
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET;

if (!WEBHOOK_SECRET) {
  throw new Error("WEBHOOK_SECRET environment variable is required");
}

// Verify webhook signature
function verifyWebhookSignature(req) {
  const receivedSignature = req.headers["x-webhook-signature"];

  if (!receivedSignature) {
    return false;
  }

  const expectedSignature = crypto
    .createHmac("sha256", WEBHOOK_SECRET)
    .update(req.rawBody)
    .digest("hex");

  return crypto.timingSafeEqual(
    Buffer.from(receivedSignature),
    Buffer.from(expectedSignature)
  );
}

// Validate timestamp (optional but recommended)
function isTimestampValid(timestamp, maxAgeSeconds = 300) {
  const now = Math.floor(Date.now() / 1000);
  const age = now - parseInt(timestamp);
  return age < maxAgeSeconds && age > -60;
}

// Webhook endpoint
app.post("/webhooks/autosend", async (req, res) => {
  const deliveryId = req.headers["x-webhook-delivery-id"];
  const timestamp = req.headers["x-webhook-timestamp"];

  // Validate timestamp
  if (!isTimestampValid(timestamp)) {
    console.error("Invalid timestamp", { deliveryId, timestamp });
    return res.status(401).json({ error: "Invalid timestamp" });
  }

  // Verify signature
  if (!verifyWebhookSignature(req)) {
    console.error("Invalid signature", { deliveryId });
    return res.status(401).json({ error: "Invalid signature" });
  }

  // Process webhook
  const { event, data } = req.body;

  console.log("Webhook received and verified", {
    deliveryId,
    event,
    timestamp: new Date(parseInt(timestamp) * 1000).toISOString(),
  });

  try {
    // Queue for background processing
    await processWebhookAsync(event, data);

    res.status(200).json({ received: true });
  } catch (error) {
    console.error("Error processing webhook", { deliveryId, error });
    res.status(500).json({ error: "Internal error" });
  }
});

app.listen(3000, () => {
  console.log("Webhook server listening on port 3000");
});
```

---

## Related Resources

- [Introduction](./WEBHOOKS_INTRODUCTION.md) - Getting started with webhooks
- [Event Types](./WEBHOOKS_EVENT_TYPES.md) - Complete list of webhook events
- [Retries and Replays](./WEBHOOKS_RETRIES.md) - Retry logic and manual replay

---

**Last Updated**: November 12, 2025
