---
title: "Retries and Replays"
description: "Learn how AutoSend automatically handles failed webhook deliveries."
sidebarTitle: " Retries and Replays"
icon: "arrow-rotate-left"
---

import { AUTOSEND_PATHS } from '/snippets/autosendPaths.mdx';
import { APP_PATHS } from '/snippets/appPaths.mdx';

## Automatic Retries

AutoSend automatically retries webhook deliveries that fail due to network errors, timeouts, or non-2xx status codes from your endpoint.

### Retry Schedule

If AutoSend does not receive a 2xx (200-299) response from your webhook endpoint, we will retry the webhook delivery using an **exponential backoff strategy**.

| Attempt   | Approximate Delay After Previous Failure |
| --------- | ---------------------------------------- |
| 1st Retry | ~5 seconds                               |
| 2nd Retry | ~10 seconds                              |
| 3rd Retry | ~20 seconds                              |

**Total Retry Attempts**: 3 retries (4 total delivery attempts including the initial attempt)

**Backoff Strategy**: Exponential backoff starting with a 5-second delay, doubling with each retry

**Request Timeout**: Each delivery attempt will timeout after **10 seconds** if no response is received

### Example Timeline

```
Initial Attempt:  10:00:00 - Failed (500 Internal Server Error)
1st Retry:        10:00:05 - Failed (Timeout after 10s)
2nd Retry:        10:00:15 - Failed (503 Service Unavailable)
3rd Retry:        10:00:35 - Success (200 OK)
```

---

## When Retries Occur

### Retry Triggers

AutoSend will retry webhook deliveries when:

- **Non-2xx status codes** are returned (400, 401, 403, 404, 500, 502, 503, 504, etc.)
- **Network errors** occur (connection refused, DNS resolution failure, etc.)
- **Timeouts** happen (no response within 10 seconds)
- **SSL/TLS errors** are encountered
- **Request aborted** due to timeout

### No Retry for Success

If your endpoint returns any 2xx status code (200-299), the delivery is marked as successful and no retries will occur.

```javascript
// ✅ These responses mark delivery as successful (no retry)
res.status(200).json({ received: true });
res.status(201).json({ queued: true });
res.status(202).json({ accepted: true });

// ❌ These responses trigger retries
res.status(400).json({ error: 'Bad request' });
res.status(401).json({ error: 'Unauthorized' });
res.status(500).json({ error: 'Internal error' });
res.status(503).json({ error: 'Service unavailable' });
```

---

## Webhook Headers

Every webhook delivery includes these headers:

| Header                  | Description                                       | Example                  |
| ----------------------- | ------------------------------------------------- | ------------------------ |
| `Content-Type`          | Always `application/json`                         | `application/json`       |
| `X-Webhook-Signature`   | HMAC-SHA256 signature for verification            | `a1b2c3d4e5f6...`        |
| `X-Webhook-Event`       | The event type being delivered                    | `email.sent`             |
| `X-Webhook-Delivery-Id` | Unique ID for this delivery (same across retries) | `deliver-webhook-123456` |
| `X-Webhook-Timestamp`   | Unix timestamp (milliseconds) when sent           | `1699876543210`          |

**Important**: The `X-Webhook-Delivery-Id` remains the same across all retry attempts for the same webhook event, making it perfect for implementing idempotency.

---

## After All Retries Fail

After the conclusion of all retry attempts (initial + 3 retries = 4 total attempts), if the webhook still hasn't been delivered successfully, the delivery will be marked as **failed** in the system.

### What Happens Next

- The delivery log will show the final failure status
- The webhook's `failureCount` is incremented
- The webhook's `lastFailedAt` timestamp is updated
- Failed delivery records are kept for **48 hours** for debugging
- AutoSend will **not** automatically retry it again

### Webhook Auto-Disable (Optional)

By default, webhooks are NOT automatically disabled after consecutive failures. However, the system tracks:

- `failureCount`: Number of consecutive delivery failures
- `MAX_FAILURES` constant: Set to 5 (currently not enforced but available for future use)

You can monitor these metrics to manually disable problematic webhooks.

---

## Delivery Logs

### Log Retention

AutoSend keeps delivery attempt logs for debugging:

- **Successful deliveries**: Retained for **24 hours**
- **Failed deliveries**: Retained for **48 hours**
- **Maximum completed jobs kept**: 1,000 most recent

### Log Information

Each delivery log includes:

- Webhook ID and organization/project IDs
- Event type
- Full payload sent
- Destination URL
- HTTP status code
- Response body and headers
- Success/failure status
- Error message (if failed)
- Number of attempts made
- Duration of the request (in milliseconds)
- Timestamp of the delivery attempt

---

## Monitoring Your Webhooks

### Check Webhook Status

Monitor your webhooks from the AutoSend dashboard:

<Steps>
  <Step title="Navigate to Webhooks from the AutoSend sidebar" titleSize="h3">
    
  </Step>
  <Step title="View your webhooks with their current status" titleSize="h3">
    - **Active** (green) - Webhook is enabled and functional
    - **Inactive** (gray) - Webhook is disabled
    - **Disabled** (red) - Webhook has been disabled due to issues
  </Step>
</Steps>

### Webhook Health Metrics

Each webhook tracks important metrics:

| Metric            | Description                               |
| ----------------- | ----------------------------------------- |
| `failureCount`    | Number of consecutive delivery failures   |
| `lastSuccessAt`   | Timestamp of last successful delivery     |
| `lastFailedAt`    | Timestamp of last failed delivery         |
| `lastDeliveredAt` | Timestamp of last delivery attempt (any)  |
| `isActive`        | Whether the webhook is enabled            |
| `status`          | Current status (active/inactive/disabled) |

These metrics are updated automatically:

- **On success**: `failureCount` resets to 0, `lastSuccessAt` and `lastDeliveredAt` are updated
- **On failure**: `failureCount` increments by 1, `lastFailedAt` is updated

### Implement Your Own Monitoring

Set up your own monitoring for webhook health:

```javascript Nodejs expandable
// Example: Check webhook health periodically
async function monitorWebhookHealth() {
  // Fetch webhook delivery logs from your database
  const recentDeliveries = await db.webhookDeliveryLogs.find({
    createdAt: { $gte: new Date(Date.now() - 3600000) }, // Last hour
  });

  const failureCount = recentDeliveries.filter((d) => !d.success).length;
  const successCount = recentDeliveries.filter((d) => d.success).length;
  const totalDeliveries = recentDeliveries.length;
  const successRate =
    totalDeliveries > 0 ? (successCount / totalDeliveries) * 100 : 100;

  // Calculate average response time
  const avgDuration =
    recentDeliveries.reduce((sum, d) => sum + d.duration, 0) / totalDeliveries;

  console.log({
    totalDeliveries,
    successCount,
    failureCount,
    successRate: `${successRate.toFixed(2)}%`,
    avgResponseTime: `${avgDuration.toFixed(0)}ms`,
  });

  // Alert if success rate drops
  if (successRate < 90) {
    await sendAlert({
      title: 'Webhook Health Alert',
      message: `Webhook success rate dropped to ${successRate.toFixed(2)}%`,
      details: {
        successCount,
        failureCount,
        totalDeliveries,
      },
      severity: 'warning',
    });
  }

  // Alert if response time is slow
  if (avgDuration > 5000) {
    await sendAlert({
      title: 'Webhook Performance Alert',
      message: `Average webhook response time is ${avgDuration.toFixed(0)}ms`,
      severity: 'warning',
    });
  }
}

// Run every 5 minutes
setInterval(monitorWebhookHealth, 5 * 60 * 1000);
```

---

## Best Practices

<AccordionGroup>
  <Accordion title="Return 2xx for Successful Processing">
    Always return a 2xx status code when your endpoint successfully receives and processes a webhook:

    ```javascript Nodejs expandable
    app.post("/webhooks/autosend", async (req, res) => {
      try {
        // Verify signature first
        const signature = req.headers["x-webhook-signature"];
        const body = JSON.stringify(req.body);
    
        if (!verifySignature(signature, body, WEBHOOK_SECRET)) {
          // Return 401 for invalid signature (will retry)
          // Or return 200 to prevent retries for invalid signatures
          return res.status(401).json({ error: "Invalid signature" });
        }
    
        // Queue for background processing
        await queue.add("process-webhook", {
          deliveryId: req.headers["x-webhook-delivery-id"],
          event: req.body.type,
          data: req.body.data,
        });
    
        // Return 200 immediately - don't wait for processing
        res.status(200).json({ received: true });
      } catch (error) {
        console.error("Webhook processing error:", error);
        // Return 500 for temporary errors (will retry)
        res.status(500).json({ error: "Internal error" });
      }
    });
    ```
  </Accordion>
  <Accordion title="Implement Idempotency with Delivery ID">
    Use the `X-Webhook-Delivery-Id` header to prevent duplicate processing during retries:

    ```javascript Nodejs expandable
    // Using Redis for idempotency tracking
    const redis = require("redis");
    const client = redis.createClient();
    
    app.post("/webhooks/autosend", async (req, res) => {
      const deliveryId = req.headers["x-webhook-delivery-id"];
      const ttl = 86400; // 24 hours
    
      // Check if already processed
      const exists = await client.exists(`webhook:${deliveryId}`);
      if (exists) {
        console.log(`Duplicate delivery ${deliveryId}, skipping`);
        return res.status(200).json({ received: true, duplicate: true });
      }
    
      try {
        // Process the webhook
        await processWebhook(req.body);
    
        // Mark as processed (with TTL to auto-cleanup)
        await client.setex(`webhook:${deliveryId}`, ttl, "processed");
    
        res.status(200).json({ received: true });
      } catch (error) {
        // Don't mark as processed on error so it can be retried
        console.error("Processing failed:", error);
        res.status(500).json({ error: "Processing failed" });
      }
    });
    ```

    **Alternative: Database-based idempotency**

    ```javascript Nodejs expandable
    app.post("/webhooks/autosend", async (req, res) => {
      const deliveryId = req.headers["x-webhook-delivery-id"];
    
      try {
        // Try to insert the delivery ID (unique constraint)
        await db.webhookDeliveries.insertOne({
          deliveryId,
          receivedAt: new Date(),
          processed: false,
        });
      } catch (error) {
        if (error.code === 11000) {
          // Duplicate key - already processed
          console.log(`Duplicate delivery ${deliveryId}`);
          return res.status(200).json({ received: true, duplicate: true });
        }
        throw error;
      }
    
      try {
        await processWebhook(req.body);
    
        // Mark as processed
        await db.webhookDeliveries.updateOne(
          { deliveryId },
          { $set: { processed: true, processedAt: new Date() } }
        );
    
        res.status(200).json({ received: true });
      } catch (error) {
        console.error("Processing failed:", error);
        res.status(500).json({ error: "Processing failed" });
      }
    });
    ```
  </Accordion>
  <Accordion title="Differentiate Between Temporary and Permanent Errors">
    Return appropriate status codes based on the type of error:

    ```javascript Nodejs expandable
    app.post("/webhooks/autosend", async (req, res) => {
      try {
        // Verify signature
        const signature = req.headers["x-webhook-signature"];
        const isValid = verifySignature(signature, req.body, WEBHOOK_SECRET);
    
        if (!isValid) {
          // Invalid signature is a permanent error
          // Return 200 to prevent unnecessary retries
          return res.status(200).json({
            error: "Invalid signature",
            retryable: false
          });
        }
    
        // Process webhook
        await processWebhook(req.body);
        res.status(200).json({ received: true });
      } catch (error) {
        console.error("Webhook error:", error);
    
        // Determine if error is temporary or permanent
        if (error.code === "ECONNREFUSED" || error.code === "ETIMEDOUT") {
          // Temporary database/service error - retry
          return res.status(500).json({
            error: "Service temporarily unavailable",
            retryable: true
          });
        } else if (error.name === "ValidationError") {
          // Permanent error - bad data, don't retry
          return res.status(200).json({
            error: "Invalid data format",
            retryable: false
          });
        } else {
          // Unknown error - retry to be safe
          return res.status(500).json({
            error: "Internal error",
            retryable: true
          });
        }
      }
    });
    ```
  </Accordion>
  <Accordion title="Respond Quickly (Under 10 Seconds)">
    Your endpoint MUST respond within 10 seconds or the request will timeout. Process webhooks asynchronously:

    ```javascript Nodejs expandable
    const Queue = require("bull");
    const webhookQueue = new Queue("webhooks", {
      redis: { host: "localhost", port: 6379 },
    });
    
    // ❌ Bad - Synchronous processing (may timeout)
    app.post("/webhooks/autosend", async (req, res) => {
      await updateDatabase(req.body);      // 2 seconds
      await sendToAnalytics(req.body);     // 3 seconds
      await notifySlack(req.body);         // 2 seconds
      await triggerWorkflow(req.body);     // 4 seconds
      // Total: 11 seconds - WILL TIMEOUT!
    
      res.status(200).json({ received: true });
    });
    
    // ✅ Good - Asynchronous processing
    app.post("/webhooks/autosend", async (req, res) => {
      const deliveryId = req.headers["x-webhook-delivery-id"];
    
      // Queue for background processing (fast!)
      await webhookQueue.add("process", {
        deliveryId,
        event: req.body.type,
        data: req.body.data,
      });
    
      // Respond immediately (< 100ms)
      res.status(200).json({ received: true });
    });
    
    // Process in background worker
    webhookQueue.process("process", async (job) => {
      const { deliveryId, event, data } = job.data;
    
      console.log(`Processing webhook ${deliveryId} for event ${event}`);
    
      await updateDatabase(data);
      await sendToAnalytics(data);
      await notifySlack(data);
      await triggerWorkflow(data);
    
      console.log(`Completed processing webhook ${deliveryId}`);
    });
    ```
  </Accordion>
  <Accordion title="Log All Delivery Attempts">
    Keep detailed logs of all webhook delivery attempts for debugging:

    ```javascript Nodejs expandable
    const winston = require("winston");
    
    const logger = winston.createLogger({
      level: "info",
      format: winston.format.json(),
      transports: [
        new winston.transports.File({ filename: "webhooks.log" }),
        new winston.transports.Console(),
      ],
    });
    
    app.post("/webhooks/autosend", async (req, res) => {
      const deliveryId = req.headers["x-webhook-delivery-id"];
      const event = req.body.type;
      const timestamp = req.headers["x-webhook-timestamp"];
    
      logger.info("Webhook received", {
        deliveryId,
        event,
        timestamp,
        receivedAt: new Date().toISOString(),
      });
    
      try {
        await processWebhook(req.body);
    
        logger.info("Webhook processed successfully", {
          deliveryId,
          event,
          processingTime: Date.now() - parseInt(timestamp),
        });
    
        res.status(200).json({ received: true });
      } catch (error) {
        logger.error("Webhook processing failed", {
          deliveryId,
          event,
          error: error.message,
          stack: error.stack,
        });
    
        res.status(500).json({ error: "Processing failed" });
      }
    });
    ```
  </Accordion>
  <Accordion title="Test Retry Behavior">
    Test how your endpoint handles retries in development:

    ```javascript Nodejs expandable
    // Simulate intermittent failures for testing
    const deliveryAttempts = new Map();
    
    app.post("/webhooks/autosend", async (req, res) => {
      const deliveryId = req.headers["x-webhook-delivery-id"];
    
      // Track attempts for this delivery
      const attempts = (deliveryAttempts.get(deliveryId) || 0) + 1;
      deliveryAttempts.set(deliveryId, attempts);
    
      console.log(`Delivery ${deliveryId} - Attempt ${attempts}`);
    
      // Simulate: Fail first 2 attempts, succeed on 3rd
      if (attempts <= 2) {
        console.log(`Simulating failure on attempt ${attempts}`);
        return res.status(500).json({ error: "Simulated error" });
      }
    
      console.log(`Success on attempt ${attempts}`);
    
      // Process webhook
      await processWebhook(req.body);
    
      // Clean up tracking
      deliveryAttempts.delete(deliveryId);
    
      res.status(200).json({ received: true, attempts });
    });
    ```
  </Accordion>
  <Accordion title="Handle Concurrent Deliveries">
    AutoSend processes up to 5 webhooks concurrently. Ensure your endpoint can handle concurrent requests:

    ```javascript Nodejs expandable
    const express = require("express");
    const cluster = require("cluster");
    const os = require("os");
    
    if (cluster.isMaster) {
      // Fork workers (one per CPU core)
      const numCPUs = os.cpus().length;
      console.log(`Master process starting ${numCPUs} workers`);
    
      for (let i = 0; i < numCPUs; i++) {
        cluster.fork();
      }
    
      cluster.on("exit", (worker) => {
        console.log(`Worker ${worker.process.pid} died, starting new worker`);
        cluster.fork();
      });
    } else {
      // Worker process
      const app = express();
      app.use(express.json());
    
      app.post("/webhooks/autosend", async (req, res) => {
        try {
          await processWebhook(req.body);
          res.status(200).json({ received: true });
        } catch (error) {
          res.status(500).json({ error: "Processing failed" });
        }
      });
    
      app.listen(3000, () => {
        console.log(`Worker ${process.pid} listening on port 3000`);
      });
    }
    ```
  </Accordion>
</AccordionGroup>

---

## Troubleshooting

---

## Related Resources

<Columns cols={2}>
  <Card title="Introduction" icon="book" iconType="duotone" href="APP_PATHS.webhookIntroduction">
    Getting started with webhooks
  </Card>
  {' '}

  <Card title="Event Types" icon="list" iconType="duotone" href="APP_PATHS.webhookEventType">
    Complete list of webhook events
  </Card>
  {' '}

  <Card title="Verify Webhook Requests" icon="shield-check" iconType="duotone" href="APP_PATHS.webhookVerifyRequests">
    Security and signature verification
  </Card>
  <Card title="Webhooks" icon="gear" iconType="duotone" href="AUTOSEND_PATHS.webhooks">
    Manage your webhooks from the AutoSend sidebar
  </Card>
</Columns>